# 链接器第10部分

## 并行链接

链接过程可以在某种程度上并行化。这可以帮助隐藏I/O延迟，并可以更好地利用现代多核系统。我在gold中的意图是使用这些想法来加速链接过程。

可以并行化的第一个领域是读取所有输入文件的符号和重定位条目。符号必须按顺序处理；否则，链接器将难以正确解析多重定义。特别是，在处理归档之前使用的所有符号必须在处理归档之前完全处理，否则链接器将不知道要包含归档中的哪些成员（我想我还没有讨论过归档）。然而，尽管有这些排序要求，实际的I/O仍然可以并行进行，这可能会带来好处。

在读取所有符号和重定位之后，链接器必须完成所有输入内容的布局。大部分这种工作无法并行进行，因为设置一种类型内容的位置需要知道所有前面类型内容的大小。在进行布局时，链接器可以确定需要写出的所有数据在输出文件中的最终位置。

布局完成后，读取内容、应用重定位和将内容写入输出文件的过程可以完全并行化。每个输入文件可以单独处理。

由于在布局阶段后已知输出文件的最终大小，因此可以对输出文件使用mmap。当不进行代码松弛时，就可以将输入内容直接读取到输出文件中的适当位置，并在那里进行重定位。这减少了所需的系统调用数量，理想情况下将允许操作系统对输出文件进行最优的磁盘I/O。

今晚就到这里。明天还会有更多内容。

## 归档

归档是一种传统的Unix打包格式。它们由ar程序创建，通常以.a扩展名命名。归档通过-l选项传递给Unix链接器。

虽然ar程序能够从任何类型的文件创建归档，但它通常用于将目标文件放入归档中。当它用于这个目的时，它会为归档创建一个符号表。符号表列出了任何目标文件在归档中定义的所有符号，并且对于每个符号指出了哪个目标文件定义它。最初，符号表是由ranlib程序创建的，但现在它总是由ar默认创建（尽管如此，许多Makefile仍然不必要地运行ranlib）。

当链接器看到一个归档时，它会查看归档的符号表。对于每个符号，链接器检查它是否看到了对该符号的未定义引用而没有看到定义。如果是这种情况，它就从归档中提取目标文件并将其包含在链接中。换句话说，链接器提取定义了已引用但尚未定义的符号的所有目标文件。

这个操作重复进行，直到无法从归档中定义更多符号。这允许归档中的目标文件引用同一归档中其他目标文件定义的符号，而不用担心它们出现的顺序。

注意，链接器考虑归档在命令行上相对于其他目标文件和归档的位置。如果一个目标文件在命令行上出现在归档之后，那么该归档将不会用于定义该目标文件引用的符号。

通常，如果归档为公共符号提供定义，链接器不会包含它们。你会记得，如果链接器看到一个公共符号后跟一个同名的定义符号，它会将公共符号视为未定义引用。只有在有其他原因将定义符号包含在链接中时，这才会发生；定义符号不会从归档中被拉出。

在旧的基于a.out的SunOS系统上，归档中的公共符号有一个有趣的转折。如果链接器看到一个公共符号，然后在归档中看到一个公共符号，它不会包含归档中的目标文件，但如果归档中的大小更大，它会将公共符号的大小更改为归档中的大小。C库在实现stdin变量时依赖于这种行为。

我的下一篇文章应该在周一发布。
