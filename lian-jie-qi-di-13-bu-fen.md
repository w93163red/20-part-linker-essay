# 链接器第13部分

## 符号版本再探

我发现符号版本是链接器的一个较为棘手的方面之一。符号版本是链接器在第二次及后续看到特定符号时所做的事情。我已经在之前的几个条目中涉及了这个主题，但让我们更深入地看一下。

从用户的角度来看，我认为值得再讨论一下符号版本。

正如我之前讨论过的，符号版本是ELF的一个扩展，旨在解决一个特定问题：使得可以升级共享库而不改变现有的可执行文件。也就是说，它们为共享库提供了向后兼容性。还有一些相关的问题是符号版本不能解决的。它们不为共享库提供前向兼容性：如果你升级你的可执行文件，你可能也需要升级你的共享库（如果能够构建你的可执行文件来对抗共享库的旧版本会很好，但在实践中这很难实现）。它们只在共享库接口工作：它们不能帮助系统调用的ABI变化，这是在内核接口。它们不能帮助解决共享不兼容版本的共享库的问题，这可能发生在一个复杂的应用程序由几个具有不兼容依赖关系的现有共享库构建时。

尽管有这些限制，共享库的向后兼容性仍然是一个重要问题。使用符号版本来确保向后兼容性需要一种谨慎和严格的方法。你必须从对每个符号应用版本开始。如果共享库中的符号没有版本，那么就不可能以向后兼容的方式更改它。然后你必须密切关注每个符号的ABI。如果符号的ABI因任何原因发生变化，你必须提供一个实现旧ABI的副本。该副本应该标记为原始版本。新符号必须给予新版本。

符号的ABI可以通过多种方式发生变化。函数参数类型或返回类型的任何变化都是ABI变化。变量类型的任何变化都是ABI变化。如果参数或返回类型是结构体或类，那么任何字段类型的变化都是ABI变化 - 也就是说，如果结构体中的一个字段指向另一个结构体，而那个结构体发生了变化，ABI就发生了变化。如果一个函数被定义为返回一个枚举的实例，并且向该枚举添加了一个新值，那就是ABI变化。换句话说，即使是小的变化也可能是ABI变化。你需要问的问题是：已经编译的现有代码是否可以继续使用新符号而无需任何更改？如果答案是否定的，你就有了一个ABI变化，你必须定义一个新的符号版本。

在编写实现旧ABI的符号时，如果你不只是复制现有代码，你必须非常小心。你必须确保它真的实现了旧的ABI。

使用C++时有一些特殊的挑战。向类添加新的虚函数可能是使用该类的任何函数的ABI变化。在这种情况下提供类的向后兼容版本非常尴尬 - 没有自然的方法来指定旧版本的虚表或RTTI信息的名称和版本。

当然，你绝不能删除任何符号。

正确地获得所有细节，并验证你得到它们正确，需要极大的注意细节。不幸的是，我不知道有任何工具可以帮助人们编写正确的版本脚本，或验证它们。尽管如此，如果正确实施，结果是好的：现有的可执行文件将继续运行。

## 静态链接 vs. 动态链接

当然，还有另一种方法可以确保现有的可执行文件继续运行：静态链接它们，不使用任何共享库。这将把它们的ABI问题限制在内核接口，这通常比库接口小得多。

静态链接有性能权衡。静态链接的程序不能受益于与同时执行的其他程序共享库。另一方面，静态链接的程序在库内执行时不必支付位置无关代码的性能惩罚。

只有动态链接才能升级共享库。这种升级可以提供错误修复和更好的性能。此外，动态链接器可以选择适合特定平台的共享库版本，这也可以帮助提高性能。

静态链接允许更可靠地测试程序。你只需要担心内核变化，而不需要担心共享库变化。

有些人认为动态链接总是优越的。我认为两边都有好处，哪种选择最好取决于具体情况。

周一会有更多内容。如果你认为我应该写任何尚未在评论中提到的特定链接器相关主题，请让我知道。

