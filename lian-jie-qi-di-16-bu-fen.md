# 链接器第16部分

## C++模板实例化

还有更多C++在链接时的有趣之处，尽管与链接器本身的关系较少。C++程序可以声明模板，并用特定类型实例化它们。理想情况下，这些特定的实例化应该在程序中只出现一次，而不是每个实例化模板的源文件中都出现一次。有几种方法可以实现这一点。

对于支持COMDAT和模糊链接的目标文件格式（我昨天描述过），最简单和最可靠的机制是让编译器为源文件生成所有需要的模板实例化，并将它们放入目标文件中。它们应该被标记为COMDAT，这样链接器就会丢弃所有副本只保留一个。这确保了所有模板实例化在链接时都可用，并且可执行文件只有一个副本。这是gcc在支持它的系统上的默认做法。明显的缺点是编译所有重复的模板实例化所需的时间以及它们在目标文件中占用的空间。这有时被称为Borland模型，因为这是Borland的C++编译器所做的。

另一种方法是在编译时不生成任何模板实例化。相反，在链接时，如果我们需要一个没有找到的模板实例化，就调用编译器来构建它。这可以通过运行链接器并查找错误消息来完成，或者通过使用链接器插件来处理未定义的符号错误。这种方法的难点在于找到要编译的源代码以及找到正确的选项传递给编译器。通常，源代码在编译时被放入某种存储库文件中，以便在链接时可用。让编译步骤正确的复杂性是为什么这种方法不是默认的原因。然而，当它工作时，它可能比重复实例化方法更快。这有时被称为Cfront模型。

gcc还支持显式模板实例化，可以用来精确控制模板在何处实例化。如果你对整个源代码库有完全控制，并且可以在某个中心位置实例化所有需要的模板，这种方法可以工作。gcc的C++库libstdc++就使用了这种方法。

C++定义了一个export关键字，应该允许以这样一种方式导出模板定义，使它们可以被编译器重新读取。gcc不支持这个关键字。如果它工作，它可能是使用Cfront模型的存储库时稍微更可靠的方式。

## 异常帧

C++和其他语言支持异常。当在一个函数中抛出异常并在另一个函数中捕获时，程序需要重置栈指针和寄存器到异常被捕获的点。在重置栈指针时，程序需要识别正在丢弃的栈部分中的所有局部变量，并运行它们的析构函数（如果有的话）。这个过程称为展开栈。

展开栈所需的信息通常存储在程序的表中。支持库代码用于读取表并执行必要的操作。我不会在这里描述这些表的细节。然而，有一个适用于它们的链接器优化。

支持库需要能够在运行时发生异常时找到异常表。异常可以在一个共享库中抛出并在另一个共享库中捕获，所以找到所有需要的异常表可能是一个非平凡的操作。可以使用的一种方法是在程序启动时或共享库加载时注册异常表。可以使用全局构造函数机制在正确的时间进行注册。

然而，这种方法对异常施加了运行时成本，因为它需要更长的时间来启动程序。因此，这不是理想的。链接器可以通过构建可用于查找异常表的表来优化这一点。GNU链接器构建的表经过排序，以便运行时库快速查找。这些表被放入PT\_GNU\_EH\_FRAME段中。然后支持库需要一种方法来查找这种类型的段。这是通过GNU动态链接器提供的dl\_iterate\_phdr API完成的。

请注意，如果编译器认为链接器将生成PT\_GNU\_EH\_FRAME段，它就不会生成注册异常表的启动代码。因此，链接器不能不创建这个段。

由于GNU链接器需要查看异常表以生成PT\_GNU\_EH\_FRAME段，它还会通过丢弃重复的异常表信息来进行优化。

我知道这一节相当缺乏细节。我希望总体思路是清楚的。

明天还会有更多内容。

