---
description: 2007年8月27日下午10:47 · 归档于编程
---

# 链接器第4部分

## 共享库

我们已经谈论了一些关于目标文件和可执行文件的样子,那么共享库是什么样子的呢?我将重点关注SVR4(以及GNU/Linux等)中使用的ELF共享库,因为它们是最灵活的共享库实现,也是我最熟悉的。

Windows共享库,称为DLL,不太灵活,因为你必须根据代码是否会进入共享库来编译代码。你还必须在源代码中表达符号可见性。这本身不是坏事,事实上ELF随着时间的推移也采纳了其中的一些想法,但ELF格式在链接时做出更多决定,因此更强大。

当程序链接器创建共享库时,它还不知道该共享库将在哪个虚拟地址运行。事实上,在不同的进程中,同一个共享库将在不同的地址运行,这取决于动态链接器做出的决定。这意味着共享库代码必须是位置无关的。更准确地说,它必须在动态链接器完成加载后是位置无关的。动态链接器总是可以将任何代码片段转换为在任何虚拟地址运行,只要有足够的重定位信息。然而,执行重定位计算必须在每次程序启动时进行,这意味着它将启动得更慢。因此,任何共享库系统都寻求生成位置无关代码,该代码在运行时需要最少数量的重定位,同时仍然以接近位置相关代码的运行时效率运行。

另一个复杂性是ELF共享库被设计为大致等同于普通归档。这意味着默认情况下,主可执行文件可能会覆盖共享库中的符号,使得共享库中的引用将调用可执行文件中的定义,即使共享库也定义了相同的符号。例如,可执行文件可能定义自己版本的malloc。C库也定义了malloc,并且C库包含调用malloc的代码。如果可执行文件自己定义了malloc,它将覆盖C库中的函数。当C库中的其他函数调用malloc时,它将调用可执行文件中的定义,而不是C库中的定义。

因此,对于任何特定的ELF实现,有不同的要求朝不同方向拉动。正确的实现选择将取决于处理器的特性。话虽如此,大多数(但不是全部)处理器做出相当相似的决定。我将在这里描述常见的情况。i386是使用常见情况的处理器的一个例子;PowerPC是做出一些不同决定的处理器的一个例子。

在常见情况下,代码可以以两种不同的模式编译。默认情况下,代码是位置相关的。将位置相关代码放入共享库将导致程序链接器生成大量重定位信息,并导致动态链接器在运行时进行大量处理。代码也可以在位置无关模式下编译,通常使用-fpic选项。当调用非静态函数或引用全局或静态变量时,位置无关代码稍慢。然而,它需要的重定位信息要少得多,因此动态链接器将更快地启动程序。

位置无关代码将通过过程链接表或PLT调用非静态函数。这个PLT在.o文件中不存在。在.o文件中,使用PLT由特殊重定位指示。当程序链接器处理这种重定位时,它将在PLT中创建一个条目。它将调整指令,使其成为对PLT条目的PC相对调用。PC相对调用本质上是位置无关的,因此本身不需要重定位条目。程序链接器将为PLT条目创建一个重定位,告诉动态链接器哪个符号与该条目关联。这个过程将共享库中的动态重定位数量从每个函数调用一个减少到每个被调用函数一个。

此外,PLT条目通常由动态链接器延迟重定位。在大多数ELF系统上,可以通过在运行程序时设置LD\_BIND\_NOW环境变量来覆盖这种延迟。然而,默认情况下,动态链接器在实际代码调用相关函数之前不会实际应用对PLT的重定位。这也加快了启动时间,因为程序的许多调用不会调用每个可能的函数。考虑到共享C库时,这一点尤其正确,因为它有比任何典型程序执行的函数调用多得多的函数调用。

为了使这个工作,程序链接器将PLT条目初始化为将索引加载到某个寄存器或压入堆栈,然后分支到公共代码。公共代码回调到动态链接器,动态链接器使用索引找到适当的PLT重定位,并使用它找到被调用的函数。然后动态链接器用函数的地址初始化PLT条目,然后跳转到函数的代码。下次调用该函数时,PLT条目将直接分支到函数。

在给出一个例子之前,我将讨论位置无关代码中的另一个主要数据结构,全局偏移表或GOT。这用于全局和静态变量。对于位置无关代码中对全局变量的每个引用,编译器将生成从GOT加载以获取变量地址的指令,然后是第二次加载以获取变量的实际值。GOT的地址通常将保存在寄存器中,以允许高效访问。像PLT一样,GOT在.o文件中不存在,而是由程序链接器创建。程序链接器将创建动态重定位,动态链接器将使用它在运行时初始化GOT。与PLT不同,动态链接器总是在程序启动时完全初始化GOT。

例如,在i386上,GOT的地址保存在%ebx寄存器中。这个寄存器在位置无关代码中每个函数的入口处初始化。初始化序列因编译器而异,但通常看起来像这样:

```assembly
call __i686.get_pc_thunk.bx
add $offset,%ebx
```

函数\_\_i686.get\_pc\_thunk.bx只是这样:

```assembly
mov (%esp),%ebx
ret
```

这个指令序列使用位置无关序列获取它正在运行的地址。然后它使用偏移量获取GOT的地址。请注意,这要求GOT始终是代码的固定偏移量,无论共享库加载在哪里。也就是说,动态链接器必须将共享库作为一个固定单元加载;它不能将不同部分加载到不同的地址。

现在通过首先从%ebx加载地址的固定偏移量来读取或写入全局和静态变量。程序链接器将为GOT中的每个条目创建动态重定位,告诉动态链接器如何初始化该条目。这些重定位类型为GLOB\_DAT。

对于函数调用,程序链接器将设置PLT条目,使其看起来像这样:

```assembly
jmp *offset(%ebx)
pushl #index
jmp first_plt_entry
```

程序链接器将为PLT中的每个条目分配GOT中的一个条目。它将为GOT条目创建一个JMP\_SLOT类型的动态重定位。它将初始化GOT条目为共享库基地址加上上面代码序列中第二条指令的地址。当动态链接器对JMP\_SLOT重定位进行初始延迟绑定时,它只会将共享库加载地址与共享库基地址之间的差值添加到GOT条目中。效果是第一个jmp指令将跳转到第二条指令,该指令将推送索引条目并分支到第一个PLT条目。第一个PLT条目是特殊的,看起来像这样:

```assembly
pushl 4(%ebx)
jmp *8(%ebx)
```

这引用GOT中的第二个和第三个条目。动态链接器将初始化它们以具有适当的值,用于回调到动态链接器本身。动态链接器将使用第一个代码序列推送的索引来找到JMP\_SLOT重定位。当动态链接器确定要调用的函数时,它将将函数的地址存储到第一个代码序列引用的GOT条目中。因此,下次调用该函数时,jmp指令将直接分支到正确的代码。

这是对许多细节的快速浏览,但我希望它传达了主要思想。这意味着对于i386上的位置无关代码,对全局函数的每次调用在第一次调用后需要一条额外的指令。对全局或静态变量的每次引用需要一条额外的指令。几乎每个函数在启动时使用四条额外的指令来初始化%ebx(不引用任何全局变量的叶函数不需要初始化%ebx)。这都对程序缓存有一些负面影响。这是为了让动态链接器快速启动程序而付出的运行时性能代价。

在其他处理器上,细节自然是不同的。然而,总体风格是相似的:共享库中的位置无关代码启动更快,运行稍慢。

明天会有更多内容。

