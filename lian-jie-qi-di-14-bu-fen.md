# 链接器第14部分

## 链接时优化

我已经提到了一些特定于链接器的优化：代码松弛和不需要的节的垃圾回收。还有另一类优化发生在链接时，但实际上与编译器有关。这些优化的一般名称是链接时优化或全程序优化。

总体思路是在链接时运行编译器优化过程。在链接时运行它们的优点是编译器可以看到整个程序。这允许编译器执行在源文件单独编译时无法进行的优化。最明显的这种优化是跨源文件内联函数。另一个是优化简单函数的调用序列 - 例如，在寄存器中传递更多参数，或者知道函数不会破坏所有寄存器；这只有在编译器可以看到函数的所有调用者时才能做到。经验表明，这些和其他优化可以带来显著的性能提升。

通常，这些优化是通过让编译器将其中间表示的版本写入目标文件或某个并行文件来实现的。中间表示将是源文件的解析版本，可能已经应用了一些本地优化。有时目标文件只包含编译器中间表示，有时还包含通常的目标代码。在前一种情况下，链接时优化是必需的，在后一种情况下，它是可选的。

我知道实现链接时优化的两种典型方式。第一种方法是编译器提供一个预链接器。预链接器检查目标文件寻找存储的中间表示。当它找到一些时，它运行链接时优化通道。第二种方法是链接器本身在发现中间表示时回调到编译器。这通常通过某种插件API来完成。

虽然这些优化发生在链接时，但它们不是链接器本身的一部分，至少不是按我定义的那样。当编译器读取存储的中间表示时，它最终会以某种方式生成一个目标文件。然后链接器本身将像往常一样处理该目标文件。这些优化应该被认为是编译器的一部分。

## 初始化代码

C++允许全局变量有构造函数和析构函数。全局构造函数必须在main开始之前运行，全局析构函数必须在调用exit之后运行。要实现这一点，需要编译器和链接器合作。

a.out目标文件格式现在很少使用，但GNU a.out链接器有一个有趣的扩展。在a.out中，符号有一个一字节的类型字段。这编码了一堆调试信息，还有符号定义的节。a.out目标文件格式只支持三个节 - 文本、数据和bss。四种符号类型被定义为集合：文本集、数据集、bss集和绝对集。具有集合类型的符号允许多次定义。GNU链接器不会给出多重定义错误，而是会构建一个包含符号所有值的表。表将以一个保存条目数量的字开始，以零字结束。在输出文件中，集合符号将被定义为表开始的地址。

对于每个C++全局构造函数，编译器会生成一个名为\_\_CTOR\_LIST\_\_的文本集类型的符号。符号在目标文件中的值将是全局构造函数。链接器会将所有\_\_CTOR\_LIST\_\_函数收集到一个表中。编译器提供的启动代码会遍历\_\_CTOR\_LIST\_\_表并调用每个函数。全局析构函数以类似的方式处理，名称为\_\_DTOR\_LIST\_\_。

好了，说了这么多a.out。在ELF中，全局构造函数的处理方式非常相似，但不使用魔术符号类型。我将描述gcc的做法。定义全局构造函数的目标文件将包括一个.ctors节。编译器会安排在链接的最开始和最后链接特殊的目标文件。链接开始时的那个将为.ctors节定义一个符号；该符号将最终位于节的开始。链接结束时的那个将为.ctors节的结尾定义一个符号。编译器启动代码将在两个符号之间遍历，调用构造函数。全局析构函数以类似的方式工作，在.dtors节中。

ELF共享库的工作方式类似。当动态链接器加载共享库时，如果有DT\_INIT标签，它将调用该标签处的函数。按照惯例，ELF程序链接器会将其设置为名为\_init的函数（如果有的话）。同样，当共享库被卸载时，会调用DT\_FINI标签，程序链接器会将其设置为名为\_fini的函数。

如前所述，还有DT\_INIT\_ARRAY、DT\_PREINIT\_ARRAY和DT\_FINI\_ARRAY标签，它们是基于SHT\_INIT\_ARRAY、SHT\_PREINIT\_ARRAY和SHT\_FINI\_ARRAY节类型设置的。这是ELF中较新的方法，不需要依赖特殊的符号名称。

明天还会有更多内容。

