---
description: 2007年8月29日下午8:52 · 归档于编程
---

# 链接器第6部分

## 重定位

正如我在第2部分中所说，重定位是对内容执行的计算。正如我昨天所说，重定位还可以指示链接器采取其他操作，比如创建PLT或GOT条目。让我们仔细看看这个计算。

一般来说，重定位有一个类型、一个符号、内容中的偏移量和一个加数。

从链接器的角度来看，内容只是一系列未经解释的字节。重定位根据需要更改这些字节，以生成正确的最终可执行文件。例如，考虑C代码 `g = 0;`，其中g是一个全局变量。在i386上，编译器会将其转换为汇编语言指令，很可能是 `movl $0, g`（对于位置相关代码 - 位置无关代码会从GOT加载g的地址）。现在，C代码中的g是一个全局变量，我们或多或少都知道这是什么意思。汇编代码中的g不是那个变量。它是一个保存该变量地址的符号。

汇编器不知道全局变量g的地址，换句话说，汇编器不知道符号g的值。链接器将选择该地址。所以汇编器必须告诉链接器它需要在这条指令中使用g的地址。汇编器通过创建重定位来做到这一点。我们不为每条指令使用单独的重定位类型；相反，每个处理器都有一组适合机器架构的自然重定位类型。每种类型的重定位表达一个特定的计算。

在i386的情况下，汇编器将生成这些字节：

```
c7 05 00 00 00 00 00 00 00 00
```

c7 05是指令（movl常量到地址）。第一组四个00字节是32位常量0。第二组四个00字节是地址。汇编器通过生成（在这种情况下）R\_386\_32重定位来告诉链接器将符号g的值放入那四个字节中。对于这个重定位，符号将是g，偏移量将指向指令的最后四个字节，类型将是R\_386\_32，加数将是0（在i386的情况下，加数存储在内容中而不是在重定位本身中，但这是一个细节）。类型R\_386\_32表达了一个特定的计算，即：将符号的值和加数的32位和放入偏移量。由于i386的加数存储在内容中，这也可以表达为：将符号的值添加到偏移量处的32位字段中。当链接器执行这个计算时，指令中的地址将是全局变量g的地址。无论细节如何，重要的是要注意重定位通过应用类型选择的特定计算来调整内容。

一个确实使用加数的简单例子是：

```c
char a[10]; // 一个全局数组
char* p = &a[1]; // 在一个函数中
```

对p的赋值最终会为符号a需要一个重定位。这里的加数将是1，所以结果指令引用a + 1而不是a + 0。

为了指出重定位如何依赖于处理器，让我们考虑RISC处理器上的 `g = 0;`：PowerPC（32位模式）。在这种情况下，需要多条汇编语言指令：

```assembly
li 1,0           // 将寄存器1设置为0
lis 9,g@ha       // 将g的高调整部分加载到寄存器9
stw 1,g@l(9)     // 将寄存器1存储到寄存器9加上g的低调整部分的地址
```

lis指令将一个值加载到寄存器9的高16位，将低16位设置为零。stw指令将一个有符号的16位值添加到寄存器9以形成一个地址，然后将寄存器1的值存储在该地址。操作数的@ha部分指示汇编器生成R\_PPC\_ADDR16\_HA重定位。@l生成R\_PPC\_ADDR16\_LO重定位。这些重定位的目标是计算符号g的值并将其用作存储地址。

这足以确定这些重定位执行的计算。R\_PPC\_ADDR16\_HA重定位计算 `(SYMBOL >> 16) + ((SYMBOL & 0x8000) ? 1 : 0)`。R\_PPC\_ADDR16\_LO计算 `SYMBOL & 0xffff`。R\_PPC\_ADDR16\_HA的额外计算是因为stw指令添加有符号的16位值，这意味着如果低16位看起来是负的，我们必须相应地调整高16位。重定位的偏移量使得16位结果值存储在机器指令的适当部分。

我在这里讨论的特定重定位示例是ELF特定的，但同样类型的重定位出现在任何目标文件格式中。

我展示的例子是出现在目标文件中的重定位。正如第4部分所讨论的，如果程序链接器将它们复制到那里，这些类型的重定位也可能出现在共享库中。在ELF中，还有一些特定的重定位类型，它们从不出现在目标文件中，而只出现在共享库或可执行文件中。这些是前面讨论的JMP\_SLOT、GLOB\_DAT和RELATIVE重定位。另一种只出现在可执行文件中的重定位类型是COPY重定位，我稍后会讨论。

## 位置相关共享库

我意识到在第4部分中我忘记说明ELF共享库使用PLT和GOT表的一个重要原因。共享库的想法是允许将同一个共享库映射到不同的进程中。只有当共享库代码在每个进程中看起来相同时，这才能以最大效率工作。如果它看起来不相同，那么每个进程将需要自己的私有副本，物理内存的节省和共享将会失去。

如第4部分所讨论的，当动态链接器加载包含位置相关代码的共享库时，它必须应用一组动态重定位。这些重定位将改变共享库中的代码，它将不再可共享。

PLT和GOT的优势在于它们将重定位移到其他地方，即PLT和GOT表本身。然后这些表可以放在共享库的读写部分。共享库的这部分将比代码小得多。PLT和GOT表在使用共享库的每个进程中都会不同，但代码将是相同的。

我将在长周末休假。我的下一篇文章很可能会在周二发布。
