# 链接器第7部分

正如我们所见，链接器做的事情基本上很简单，但细节可能会变得复杂。这种复杂性是因为聪明的程序员能够看到一些小的优化来稍微加速他们的程序，有时这些优化只能在链接器中实现。每一个这样的优化都会使链接器变得更复杂一点。同时，当然，链接器必须尽可能快地运行，因为没有人愿意坐等它完成。今天我将讨论一个由链接器实现的经典小优化。

## 线程本地存储

我假设你知道什么是线程。通常，有一个全局变量在每个线程中可以具有不同的值是很有用的（如果你不明白为什么这是有用的，就相信我吧）。也就是说，变量对于程序是全局的，但特定的值是线程本地的。如果线程A将线程本地变量设置为1，然后线程B将其设置为2，那么在线程A中运行的代码将继续看到变量的值为1，而在线程B中运行的代码看到的值为2。在Posix线程中，这种类型的变量可以通过pthread\_key\_create创建，并通过pthread\_getspecific和pthread\_setspecific访问。

这些函数工作得很好，但每次访问都要进行函数调用是笨拙和不方便的。如果你可以只声明一个常规的全局变量并将其标记为线程本地，那将更有用。这就是线程本地存储（TLS）的想法，我相信这是在Sun发明的。在支持TLS的系统上，任何全局（或静态）变量都可以用\_\_thread注释。然后该变量就是线程本地的。

显然，这需要编译器的支持。它还需要程序链接器和动态链接器的支持。为了获得最大效率 - 如果不是为了获得最大效率，为什么要这样做呢？- 还需要一些内核支持。ELF系统上TLS的设计完全支持共享库，包括多个共享库和可执行文件本身使用相同的名称来引用单个TLS变量。TLS变量可以被初始化。程序可以获取TLS变量的地址，并在线程之间传递指针，所以TLS变量的地址是一个动态值，必须是全局唯一的。

这一切是如何实现的？第一步：为TLS变量定义不同的存储模型。

* 全局动态：从可执行文件或共享对象完全通用地访问TLS变量。
* 局部动态：允许访问在引用它的可执行文件或共享对象中本地绑定的变量。对所有静态TLS变量来说都是如此。对受保护的符号也是如此 - 我在第5部分描述过这些。
* 初始可执行：允许访问已知是可执行文件的TLS映像一部分的变量。这对可执行文件本身定义的所有TLS变量以及与可执行文件显式链接的共享库中的所有TLS变量都是如此。这不适用于来自共享库的访问，也不适用于通过dlopen打开的共享库中定义的TLS变量的访问。
* 局部可执行：允许访问在可执行文件本身中定义的TLS变量。

这些存储模型是按照灵活性递减的顺序定义的。现在，为了效率和简单性，支持TLS的编译器将允许开发者指定使用适当的TLS模型（使用gcc，这是通过-ftls-model选项完成的，尽管全局动态和局部动态模型也需要使用-fpic）。因此，在编译将在可执行文件中而不会在共享库中的代码时，开发者可以选择将TLS存储模型设置为初始可执行。

当然，在实践中，开发者经常不知道代码将在哪里使用。而且开发者可能不了解TLS模型的复杂性。另一方面，程序链接器知道它是在创建可执行文件还是共享库，它知道TLS变量是否在本地定义。因此，程序链接器有责任在可能的情况下自动优化对TLS变量的引用。这些引用采取重定位的形式，链接器通过以各种方式更改代码来优化引用。

程序链接器还负责将所有TLS变量收集到一个单一的TLS段中（我稍后会更多地讨论段，现在可以将它们视为一个节）。动态链接器必须将可执行文件和所有包含的共享库的TLS段组合在一起，解析动态TLS重定位，并且必须在使用dlopen时动态构建TLS段。内核必须使访问TLS段成为可能的高效操作。

这都是相当一般的。让我们做一个例子，再次针对i386 ELF。i386 ELF有三种不同的TLS实现；我将看看gnu实现。考虑这个简单的代码：

```c
__thread int i;
int foo() { return i; }
```

在全局动态模式下，这会生成像这样的i386汇编代码：

```assembly
leal i@TLSGD(,%ebx,1), %eax
call ___tls_get_addr@PLT
movl (%eax), %eax
```

回想一下第4部分，%ebx保存GOT表的地址。第一条指令将有一个针对变量i的R\_386\_TLS\_GD重定位；重定位将应用于leal指令的偏移量。当程序链接器看到这个重定位时，它将在GOT表中为TLS变量i创建两个连续的条目。第一个将获得R\_386\_TLS\_DTPMOD32动态重定位，第二个将获得R\_386\_TLS\_DTPOFF32动态重定位。动态链接器将设置DTPMOD32 GOT条目以保存定义变量的对象的模块ID。模块ID是动态链接器表中的一个索引，用于标识可执行文件或特定的共享库。动态链接器将设置DTPOFF32 GOT条目为该模块的TLS段内的偏移量。\_\_tls\_get\_addr函数将使用这些值来计算地址（这个函数还处理TLS变量的延迟分配，这是动态链接器特有的进一步优化）。注意，\_\_tls\_get\_addr实际上是由动态链接器本身实现的；因此，全局动态TLS变量在静态链接的可执行文件中是不支持的（也不需要）。

此时你可能在想pthread\_getspecific有什么不高效的。TLS的真正优势在于你看到程序链接器可以做什么。上面显示的leal; call序列是规范的：编译器在全局动态模式下总是生成相同的序列来访问TLS变量。程序链接器利用这一事实。如果程序链接器看到上面显示的代码进入可执行文件，它知道访问不必被视为全局动态；它可以被视为初始可执行。程序链接器实际上会重写代码，使其看起来像这样：

```assembly
movl %gs:0, %eax
subl $i@GOTTPOFF(%ebx), %eax
```

在这里我们看到TLS系统已经利用%gs段寄存器，与操作系统合作，指向可执行文件的TLS段。对于支持TLS的每个处理器，都会做一些这样的效率黑魔法。由于程序链接器正在构建可执行文件，它构建TLS段，并知道i在段中的偏移量。GOTTPOFF不是真正的重定位；它是在程序链接器内部创建和解析的。它当然是从GOT表到i在TLS段中地址的偏移量。原始序列中的movl (%eax), %eax保持不变，以实际加载变量的值。

实际上，如果i不是在可执行文件本身中定义的，那就是会发生的情况。在我展示的例子中，i是在可执行文件中定义的，所以程序链接器实际上可以从全局动态访问一直到局部可执行访问。那看起来像这样：

```assembly
movl %gs:0,%eax
subl $i@TPOFF,%eax
```

这里i@TPOFF只是i在TLS段内的已知偏移量。我不打算解释为什么这里使用subl而不是addl；只需说这是动态链接器中的另一个效率黑魔法。

如果你跟上了所有这些，你会看到当一个可执行文件访问在该可执行文件中定义的TLS变量时，它需要两条指令来计算地址，通常后面跟着另一条指令来实际加载或存储值。这比调用pthread\_getspecific要高效得多。诚然，当共享库访问TLS变量时，结果并不比pthread\_getspecific好多少，但也不应该更糟。而且使用\_\_thread的代码更容易编写和阅读。

这是一次真正的旋风之旅。有三种单独但相关的i386 TLS实现（称为sun、gnu和gnu2），定义了23种不同的重定位类型。我当然不打算尝试描述所有细节；无论如何我也不知道所有细节。它们都以高效访问给定存储模型的TLS变量的名义而存在。

TLS是否值得程序链接器和动态链接器增加额外的复杂性？由于这些工具用于每个程序，并且由于特别是C标准全局变量errno可以使用TLS实现，答案很可能是肯定的。
