---
description: 2007年8月24日下午10:25 · 归档于编程
---

# 链接器第3部分

继续关于链接器的笔记。

## 地址空间

地址空间只是内存的一个视图,其中每个字节都有一个地址。链接器处理三种不同类型的地址空间。

每个输入目标文件都是一个小的地址空间:内容有地址,符号和重定位通过地址引用内容。

输出程序在运行时将被放置在内存的某个位置。这是输出地址空间,我通常称之为使用虚拟内存地址。

输出程序将被加载到内存的某个位置。这是加载内存地址。在典型的Unix系统上,虚拟内存地址和加载内存地址是相同的。在嵌入式系统上,它们通常是不同的;例如,初始化数据(全局或静态变量的初始内容)可能被加载到加载内存地址的ROM中,然后复制到虚拟内存地址的RAM中。

共享库通常可以在不同进程中以不同的虚拟内存地址运行。共享库在创建时有一个基地址;这通常只是零。当动态链接器将共享库复制到进程的虚拟内存空间时,它必须应用重定位以调整共享库以在其虚拟内存地址运行。共享库系统最小化必须应用的重定位数量,因为它们在启动程序时需要时间。

## 目标文件格式

如前所述,汇编器将人类可读的汇编语言转换为目标文件。目标文件是一个二进制数据文件,以设计为链接器输入的格式编写。链接器生成可执行文件。这个可执行文件是一个二进制数据文件,以设计为操作系统或加载器输入的格式编写(即使在动态链接时也是如此,因为通常操作系统在调用动态链接器开始运行程序之前加载可执行文件)。

目标文件格式没有逻辑要求类似于可执行文件格式。然而,实际上它们通常非常相似。

大多数目标文件格式定义节。一个节通常保存内存内容,或者可能用于保存其他类型的数据。节通常有一个名称、一个类型、一个大小、一个地址和一个关联的数据数组。

目标文件格式可以分为两种一般类型:面向记录的和面向节的。

面向记录的目标文件格式定义了一系列大小不同的记录。每个记录以一些特殊代码开始,后面可能跟有数据。读取目标文件需要从头开始读取并处理每个记录。记录用于描述符号和节。重定位可能与节相关联,也可能由其他记录指定。IEEE-695和Mach-O是当今使用的面向记录的目标文件格式。

在面向节的目标文件格式中,文件头描述了一个具有指定数量节的节表。符号可能出现在文件头描述的目标文件的单独部分中,也可能出现在特殊节中。重定位可能附加到节上,也可能出现在单独的节中。可以通过读取节表,然后直接读取特定节来读取目标文件。ELF、COFF、PE和a.out是面向节的目标文件格式。

每种目标文件格式都需要能够表示调试信息。调试信息由编译器生成,由调试器读取。一般来说,链接器可以像处理任何其他类型的数据一样处理它。然而,实际上程序的调试信息可能比实际程序本身还大。链接器可以使用各种技术来减少调试信息的数量,从而减小可执行文件的大小。这可以加快链接速度,但需要链接器理解调试信息。

a.out目标文件格式使用符号表中的特殊字符串存储调试信息,称为stabs。这些特殊字符串只是具有特殊类型的符号名称。这种技术也被一些ECOFF变体和Mach-O的旧版本使用。

COFF目标文件格式使用符号表中的特殊字段存储调试信息。这种类型信息有限,对于C++来说完全不够。一种常见的解决这些限制的技术是在COFF节中嵌入stabs字符串。

ELF目标文件格式将调试信息存储在具有特殊名称的节中。调试信息可以是stabs字符串或DWARF调试格式。
