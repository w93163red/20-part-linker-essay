# 链接器第15部分

## COMDAT节

在C++中，有几种构造不明确地存在于单个位置。例如，在头文件中定义的内联函数、虚函数表和typeinfo对象。在最终链接的程序中必须只有这些构造的单个实例（实际上，我们可能可以容忍虚函数表的多个副本，但其他必须是唯一的，因为可以获取它们的地址）。不幸的是，不一定有单个目标文件应该生成它们。这些类型的构造有时被描述为具有"模糊链接"。

链接器通过使用COMDAT节来实现这些特性（可能还有其他方法，但这是我唯一知道的）。COMDAT节是一种特殊类型的节。每个COMDAT节都有一个特殊的字符串。当链接器看到具有相同特殊字符串的多个COMDAT节时，它只会保留其中一个。

例如，当C++编译器看到头文件中定义的内联函数f1，但编译器无法在所有使用中内联该函数（可能是因为某些代码获取了函数的地址），编译器将在与字符串f1关联的COMDAT节中发出f1。在链接器看到COMDAT节f1后，它将丢弃所有后续的f1 COMDAT节。

这显然引发了可能存在两个完全不同的名为f1的内联函数的可能性，它们在不同的头文件中定义。这将是一个无效的C++程序，违反了单一定义规则（通常缩写为ODR）。不幸的是，如果没有源文件包含这两个头文件，编译器将无法诊断这个错误。而且，不幸的是，链接器只会简单地丢弃重复的COMDAT节，也不会注意到这个错误。这是一个需要改进的领域（至少在GNU工具中；我不知道其他工具是否正确诊断这个错误）。

Microsoft PE目标文件格式提供COMDAT节。这些节可以被标记，以便内容不相同的重复COMDAT节会导致错误。这并不像看起来那么有用，因为不同的编译器选项可能会导致有效重复具有不同的内容。与COMDAT节关联的字符串存储在符号表中。

在我了解Microsoft PE格式之前，我按照Jason Merrill的建议，在GNU ELF链接器中引入了一种不同类型的COMDAT节。任何名称以".gnu.linkonce."开头的节都是COMDAT节。关联的字符串只是节名本身。因此，内联函数f1将被放入名为".gnu.linkonce.f1"的节中。这个简单的实现工作得足够好，但它有一个缺陷，即一些函数需要多个节中的数据；例如，指令可能在一个节中，而相关的静态数据可能在另一个节中。由于内联函数的不同实例可能被编译得不同，链接器无法可靠和一致地丢弃重复的数据（我不知道Microsoft链接器如何处理这个问题）。

最近的ELF版本引入了节组。这些实现了ELF中官方认可的COMDAT版本，并避免了".gnu.linkonce"节的问题。我在早前的博客条目中简要描述了这些。一个特殊类型为SHT\_GROUP的节包含组中节索引的列表。整个组被保留或丢弃。与组关联的字符串在符号表中找到。将字符串放在符号表中使得检索变得尴尬，但由于字符串通常是符号的名称，这意味着字符串只需要在目标文件中存储一次；这对于C++来说是一个小优化，因为符号名可能非常长。

明天还会有更多内容。

