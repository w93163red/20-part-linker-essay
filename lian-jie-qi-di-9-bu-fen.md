# 链接器第9部分

## 符号版本

共享库提供了一个API。由于可执行文件是用特定的头文件集构建并链接到共享库的特定实例，它也提供了一个ABI。能够独立于可执行文件更新共享库是很理想的。这允许修复共享库中的错误，也允许共享库和可执行文件单独分发。

有时更新共享库需要改变API，有时改变API需要改变ABI。当共享库的ABI发生变化时，就不可能在不更新可执行文件的情况下更新共享库了。这是不幸的。

例如，考虑系统C库和stat函数。当文件系统升级以支持64位文件偏移时，需要改变stat结构中一些字段的类型。这是stat的ABI的一个变化。新版本的系统库应该提供返回64位值的stat。但旧的现有可执行文件调用stat时期望32位值。

这可以通过在系统头文件中使用复杂的宏来解决。但有一个更好的方法。

更好的方法是符号版本，这是由Sun引入并由GNU工具扩展的。每个共享库可以定义一组符号版本，并为每个定义的符号分配特定版本。版本和符号分配是通过传递给程序链接器的脚本在创建共享库时完成的。

当一个可执行文件或共享库A链接到另一个共享库B时，如果A引用B中定义的具有特定版本的符号S，那么A中的未定义动态符号引用S会被赋予B中符号S的版本。当动态链接器看到A引用S的特定版本时，它会将其链接到B中的那个特定版本。如果B后来引入了S的新版本，这不会影响A，只要B继续提供S的旧版本。

例如，当stat改变时，C库会提供两个版本的stat，一个带有旧版本（例如，LIBC\_1.0），一个带有新版本（LIBC\_2.0）。新版本的stat会被标记为默认版本 - 程序链接器会使用它来满足目标文件中对stat的引用。链接到旧版本的可执行文件会需要LIBC\_1.0版本的stat，因此会继续工作。注意，甚至可以在单个程序中使用stat的两个版本，从不同的共享库访问。

如你所见，版本实际上是符号名称的一部分。最大的区别是共享库可以定义一个特定的版本，用于满足未版本化的引用。

版本也可以在目标文件中使用（这是GNU对原始Sun实现的扩展）。这对于指定版本而不需要版本脚本很有用。当符号名包含@字符时，@之前的字符串是符号的名称，@之后的字符串是版本。如果有两个连续的@字符，那么这是默认版本。

## 代码松弛

通常,程序链接器除了应用重定位外不会改变内容。然而,链接器在链接时可以执行一些优化。其中之一是代码松弛。

代码松弛本质上是处理器特定的。它涉及优化代码序列,在最终地址已知时,这些序列可以变得更小或更高效。最常见的松弛类型是针对调用指令的。例如,m68k处理器支持不同的PC相对调用指令:一个带16位偏移,一个带32位偏移。当调用目标在16位偏移范围内时,使用更短的指令更高效。在链接时将这些指令缩短的优化就称为代码松弛。

代码松弛基于重定位条目进行。链接器查找可能被松弛的重定位,并检查它们是否在范围内。如果是,链接器就应用松弛,这可能会减小内容的大小。松弛通常只能在链接器能识别被重定位的指令时进行。应用松弛可能会使其他重定位进入范围,因此松弛通常在一个循环中进行,直到没有更多机会为止。

当链接器在内容中间应用松弛时,它可能需要调整任何跨越松弛点的PC相对引用。因此,汇编器需要为所有PC相对引用生成重定位条目。当不进行松弛时,这些重定位可能不需要,因为单个内容内的PC相对引用无论内容最终位于何处都有效。然而,在进行松弛时,链接器需要检查应用于内容的所有其他重定位,并在适当的地方调整PC相对引用。这种调整只需要重新计算PC相对偏移。

当然,也可以应用不改变内容大小的松弛。例如,在MIPS上,位置无关的调用序列通常是将函数的地址加载到$25寄存器中,然后通过该寄存器进行间接调用。当调用目标在分支和调用指令的18位范围内时,使用分支和调用指令通常更高效,因为这样处理器就不必等待`$25`的加载完成就可以开始调用。这种松弛改变了指令序列,但不改变其大小。

明天会有更多内容。我为这些链接器笔记的杂乱安排道歉。我只是在想到想法时写下它们,而不是有组织地写。如果我将这些笔记整理成一篇文章,我会尽量让它们结构更清晰。
