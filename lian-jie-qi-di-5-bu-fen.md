---
description: 2007年8月28日晚上11:24 · 归档于编程
---

# 链接器第5部分

## 共享库再探

昨天我讨论了共享库的工作原理。我意识到我应该说一些关于链接器如何实现共享库的内容。这个讨论将再次是ELF特定的。

当程序链接器将位置相关代码放入共享库时，它必须将更多的重定位从目标文件复制到共享库中。它们将成为由动态链接器在运行时计算的动态重定位。有些重定位不必复制；例如，对共享库本地符号的PC相对重定位可以由程序链接器完全解析，不需要动态重定位。然而，请注意，对全局符号的PC相对重定位确实需要动态重定位；否则，主可执行文件将无法覆盖该符号。一些重定位必须存在于共享库中，但不需要是目标文件中重定位的实际副本；例如，计算共享库本地符号绝对地址的重定位通常可以替换为RELATIVE重定位，它只是指示动态链接器添加共享库的加载地址与其基地址之间的差值。使用RELATIVE重定位的优点是动态链接器可以在运行时快速计算它，因为它不需要确定符号的值。

对于位置无关代码，程序链接器有一个更困难的工作。编译器和汇编器将合作生成位置无关代码的特殊重定位。虽然处理器之间的细节不同，但通常会有PLT重定位和GOT重定位。这些重定位将指示程序链接器向PLT或GOT添加条目，并执行一些计算。例如，在i386上，位置无关代码中的函数调用将生成R\_386\_PLT32重定位。这个重定位将像往常一样引用一个符号。它将指示程序链接器为该符号添加一个PLT条目（如果还不存在的话）。然后重定位的计算是对PLT条目的PC相对引用。（名称中的32指的是引用的大小，是32位）。

昨天我描述了在i386上每个PLT条目也有一个对应的GOT条目，所以R\_386\_PLT32重定位实际上指示程序链接器创建PLT条目和GOT条目。

当程序链接器在PLT或GOT中创建条目时，它还必须生成动态重定位来告诉动态链接器关于该条目。这通常是JMP\_SLOT或GLOB\_DAT重定位。

这一切意味着程序链接器必须跟踪每个符号的PLT条目和GOT条目。最初，当然，不会有这样的条目。当链接器看到PLT或GOT重定位时，它必须检查重定位引用的符号是否已经有PLT或GOT条目，如果没有则创建一个。注意，单个符号可能同时拥有PLT条目和GOT条目；这将发生在既调用函数又获取其地址的位置无关代码中。

动态链接器对PLT和GOT表的工作只是简单地在运行时计算JMP\_SLOT和GLOB\_DAT重定位。这里的主要复杂性是我昨天描述的PLT条目的延迟评估。

C允许获取函数地址的事实引入了一个有趣的问题。在C中，你可以获取函数的地址，并且可以将该地址与另一个函数地址进行比较。问题是，如果你获取共享库中函数的地址，自然的结果将是得到PLT条目的地址。毕竟，那是对函数的调用将跳转到的地址。然而，每个共享库都有自己的PLT，因此特定函数的地址在每个共享库中都会不同。这意味着在不同共享库中生成的函数指针的比较可能会不同，而它们应该是相同的。这不是一个纯粹的假设问题；当我进行一个错误的移植时，在修复错误之前，我看到Tcl共享库在比较函数指针时失败。

在大多数处理器上，这个错误的修复是对有PLT条目但未定义的符号进行特殊标记。通常，符号将被标记为未定义，但具有非零值 - 该值将被设置为PLT条目的地址。当动态链接器搜索符号的值以用于JMP\_SLOT重定位以外的重定位时，如果它找到这样一个特殊标记的符号，它将使用非零值。这将确保对符号的所有不涉及函数调用的引用都使用相同的值。为了使这个工作，编译器和汇编器必须确保任何不涉及调用函数的函数引用都不会携带标准PLT重定位。这种函数地址的特殊处理需要在程序链接器和动态链接器中都实现。

## ELF符号

好了，关于共享库的内容足够了。让我们更详细地了解ELF符号。我不会详细描述确切的数据结构 - 请参阅ELF ABI获取这些信息。我将讨论不同的字段及其含义。许多不同类型的ELF符号也被其他目标文件格式使用，但我不会涉及这些。

ELF符号表中的一个条目有八个信息：名称、值、大小、节、绑定、类型、可见性和未定义的附加信息（目前有六个未定义位，但可能会添加更多）。在共享对象中定义的ELF符号也可能有一个关联的版本名称。

名称是显而易见的。

对于普通的定义符号，节是文件中的某个节（具体来说，符号表条目保存了节表的索引）。对于目标文件，值是相对于节起始的。对于可执行文件，值是绝对地址。对于共享库，值是相对于基地址的。

对于未定义的引用符号，节索引是特殊值SHN\_UNDEF，其值为0。节索引为SHN\_ABS（0xfff1）表示符号的值是一个绝对值，不相对于任何节。

节索引为SHN\_COMMON（0xfff2）表示一个公共符号。公共符号是为了处理Fortran公共块而发明的，它们也经常用于C中的未初始化全局变量。公共符号具有不寻常的语义。公共符号的值为零，但将大小字段设置为所需的大小。如果一个目标文件有一个公共符号，而另一个有定义，则公共符号被视为未定义引用。如果没有公共符号的定义，程序链接器就像看到了一个初始化为零的适当大小的定义。两个目标文件可能有不同大小的公共符号，在这种情况下，程序链接器将使用最大的大小。在共享库中实现公共符号语义是一个棘手的问题，最近引入的公共符号类型以及特殊的节索引在某种程度上有所帮助（参见下面关于符号类型的讨论）。

除了公共符号外，ELF符号的大小是变量或函数的大小。这主要用于调试目的。

ELF符号的绑定可以是全局的、局部的或弱的。全局符号是全局可见的。局部符号只在本地可见（例如，静态函数）。弱符号有两种风格。弱未定义引用类似于普通的未定义引用，除了当重定位引用没有定义符号的弱未定义引用时不会报错。相反，重定位将被计算为符号值为零。

允许弱定义符号与同名的非弱定义符号链接，而不会导致多重定义错误。历史上，程序链接器处理弱定义符号有两种方式。在SVR4上，如果程序链接器看到一个弱定义符号后面跟着一个同名的非弱定义符号，它会发出多重定义错误。然而，非弱定义符号后面跟着弱定义符号不会导致错误。在Solaris上，弱定义符号后面跟着非弱定义符号的处理方式是让所有引用附加到非弱定义符号，而不会出错。这种行为差异是由于ELF ABI中的一个被不同人解读不同的模糊性造成的。GNU链接器遵循Solaris的行为。

ELF符号的类型是以下之一：

* STT\_NOTYPE：没有特定类型。
* STT\_OBJECT：数据对象，如变量。
* STT\_FUNC：函数
* STT\_SECTION：与节关联的局部符号。这种类型的符号用于减少所需的局部符号数量，通过将特定节中所有对局部符号的重定位更改为使用STT\_SECTION符号。
* STT\_FILE：一个特殊符号，其名称是生成目标文件的源文件的名称。
* STT\_COMMON：公共符号。这与将节索引设置为SHN\_COMMON相同，除了在共享对象中。程序链接器通常会在共享对象中为公共符号分配空间，所以它会有一个真实的节索引。STT\_COMMON类型告诉动态链接器，尽管该符号有一个常规定义，但它是一个公共符号。
* STT\_TLS：线程本地存储区域中的符号。我将在其他日子里更详细地描述这个。

ELF符号可见性的发明是为了提供更多控制哪些符号在共享库外部可访问。基本思想是符号可能在共享库内是全局的，但在共享库外是局部的。

* STV\_DEFAULT：适用通常的可见性规则：全局符号在任何地方都可见。
* STV\_INTERNAL：符号在当前可执行文件或共享库之外不可访问。
* STV\_HIDDEN：符号在当前可执行文件或共享库之外不可见，但可能会间接访问，可能是因为一些代码获取了它的地址。
* STV\_PROTECTED：符号在当前可执行文件或共享对象之外可见，但不能被覆盖。也就是说，如果共享库中的受保护符号被共享库中的其他代码引用，那么其他代码将始终引用共享库中的符号，即使可执行文件定义了一个同名的符号。

我稍后会描述符号版本。

明天会有更多内容。
