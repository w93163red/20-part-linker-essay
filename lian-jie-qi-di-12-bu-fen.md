# 链接器第12部分

## 符号解析

我发现符号解析是链接器中较为棘手的方面之一。符号解析是链接器在第二次及后续看到特定符号时所做的事情。我已经在之前的几个条目中涉及了这个主题，但让我们更深入地看一下。

有些符号仅限于特定的目标文件。对于符号解析的目的，我们可以忽略这些，因为根据定义，链接器永远不会多次看到它们。在ELF中，这些是绑定为STB\_LOCAL的符号。

一般来说，符号通过名称解析：每个具有相同名称的符号都是同一实体。我们已经看到了这个一般规则的几个例外。符号可以有一个版本：具有相同名称但不同版本的两个符号是不同的符号。符号可以有非默认可见性：一个共享库中具有隐藏可见性的符号与不同共享库中具有相同名称的符号不同。

对于解析而言重要的符号特征是：

* 符号名称
* 符号版本
* 符号是否是默认版本
* 符号是定义、引用还是公共符号
* 符号可见性
* 符号是弱符号还是强符号（即非弱符号）
* 符号是在被包含在输出中的常规目标文件中定义的，还是在共享库中定义的
* 符号是否是线程局部的
* 符号是否指代函数或变量

符号解析的目标是确定符号的最终值。在所有符号都解析后，我们应该知道定义符号的特定目标文件或共享库，并且我们应该知道符号的类型、大小等。在读取所有符号表后，可能有些符号仍然未定义；通常，只有在某些重定位引用该符号时，这才是错误。

在这一点上，我想提出一个简单的符号解析算法，但我认为我做不到。不过，我会尽量涵盖所有要点。让我们假设我们有两个具有相同名称的符号。让我们称我们先看到的符号为A，新符号为B。（在下面的算法中，我将忽略符号可见性；可见性的影响应该是显而易见的，我希望。）

1. 如果A有版本：
   * 如果B的版本与A不同，它们实际上是不同的符号。
   * 如果B有与A相同的版本，它们是同一个符号；继续。
   * 如果B没有版本，而A是符号的默认版本，它们是同一个符号；继续。
   * 否则B可能是不同的符号。但请注意，如果A和B都是未定义的引用，那么A可能指的是符号的默认版本，但我们还不知道。在这种情况下，如果B没有版本，A和B实际上是同一个符号。在看到实际定义之前，我们无法确定。
2. 如果A没有版本：
   * 如果B没有版本，它们是同一个符号；继续。
   * 如果B有版本，并且是默认版本，它们是同一个符号；继续。
   * 否则，B可能是不同的符号，如上所述。
3. 如果A是线程局部的而B不是，或者反之，那么我们有一个错误。
4. 如果A是未定义的引用：
   * 如果B是未定义的引用，那么我们可以完成解析，并且或多或少忽略B。
   * 如果B是定义或公共符号，那么我们可以将A解析为B。
5. 如果A是目标文件中的强定义：
   * 如果B是未定义的引用，那么我们将B解析为A。
   * 如果B是目标文件中的强定义，那么我们有一个多重定义错误。
   * 如果B是目标文件中的弱定义，那么A覆盖B。实际上，B被忽略。
   * 如果B是公共符号，那么我们将B视为未定义的引用。
   * 如果B是共享库中的定义，那么A覆盖B。动态链接器将改变共享库中对B的所有引用，使其改为引用A。
6. 如果A是目标文件中的弱定义，我们的行为就像强定义的情况一样，只有一个例外：如果B是目标文件中的强定义。在原始的SVR4链接器中，这种情况被视为多重定义错误。在Solaris和GNU链接器中，这种情况是通过让B覆盖A来处理的。
7. 如果A是目标文件中的公共符号：
   * 如果B是公共符号，我们将A的大小设置为A和B的大小的最大值，然后将B视为未定义的引用。
   * 如果B是共享库中函数类型的定义，那么A覆盖B（这个奇怪的情况是为了正确处理一些Unix系统库）。
   * 否则，我们将A视为未定义的引用。
8. 如果A是共享库中的定义，那么如果B是常规目标（强或弱）中的定义，它会覆盖A。否则，我们的行为就像A是在目标文件中定义的一样。
9. 如果A是共享库中的公共符号，我们有一个有趣的情况。共享库中的符号必须有地址，所以它们不能以与目标文件中相同的意义上是公共的。但ELF确实允许共享库中的符号具有STT\_COMMON类型（这是一个相对较新的添加）。出于符号解析的目的，如果A是共享库中的公共符号，我们仍然将其视为定义，除非B也是公共符号。在后一种情况下，B覆盖A，B的大小设置为A和B的大小的最大值。

我希望我把这些都说对了。

明天还会有更多内容，假设互联网连接保持稳定。

我为暂停发帖道歉。我们在周末搬家了。上周五at\&t告诉我新DSL在我们新房子外面已经工作了。然而，直到周三它才真正在房子外面工作。然后由于内部布线的问题，直到今天它才在房子里面工作。我现在终于在家里重新上网了。

##
