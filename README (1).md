---
description: 2007年8月22日下午11:30 · 归档于编程
---

# 链接器第1部分

我一直断断续续地在开发一个新的链接器。令我惊讶的是,在谈论这件事时,我发现有些人,甚至是一些计算机程序员,对链接过程的细节并不熟悉。我决定写一些关于链接器的笔记,目标是写出一篇类似于我之前写的关于GNU配置和构建系统的文章。

由于我每天只有时间写一件事,所以我打算先在博客上写一段时间,然后再把最终的文章整理在一起。我相信我现在可能有五个读者,希望你们能接受这个偏离主题的内容。我很快就会回到随意的哲学思考和管别人闲事上来。

## 个人介绍

我有什么资格写链接器呢?

我在1988年写了我的第一个链接器,用于运行在Alpha Micro系统上的AMOS操作系统。(如果你不理解下面的描述,别担心;后面会解释所有内容)。我使用一个单一的全局数据库来注册所有符号。目标文件在编译后被检入数据库。链接过程主要需要识别包含main函数的目标文件。其他目标文件通过引用被拉入。我逆向工程了目标文件格式,这是未记录但相当简单的格式。所有这些的目标是速度,事实上这个链接器比系统自带的链接器快得多,主要是因为数据库的速度。

我在1993年和1994年写了我的第二个链接器。这个链接器是由Steve Chamberlain设计和原型化的,当时我们都在Cygnus Support工作(后来改名为Cygnus Solutions,再后来成为Red Hat的一部分)。这是对Steve几年前写的基于BFD的链接器的完全重新实现。主要目标是a.out和COFF。同样,目标是速度,特别是与原始的基于BFD的链接器相比。在SunOS 4上,这个链接器的速度几乎和对输入的.o文件运行cat程序一样快。

我现在正在开发的链接器叫做gold,将是我的第三个链接器。它专门用于ELF格式。再一次,目标是速度,在这种情况下是比我的第二个链接器更快。那个链接器多年来通过添加对ELF和共享库的支持而显著变慢。这种支持是打补丁而不是被设计进去的。新链接器的未来计划包括支持增量链接 - 这是另一种提高速度的方法。

这里有一个明显的模式:每个人都希望链接器更快。这是因为链接器所做的工作并不有趣。对于开发人员来说,链接器是一个速度减缓,一个需要相对较长时间但没有真正价值的过程。那么我们为什么还要有链接器呢?这就引出了我们的下一个话题。

## 技术介绍

### 链接器做什么?

很简单:链接器将目标文件转换为可执行文件和共享库。让我们看看这意味着什么。在使用链接器的情况下,软件开发过程包括用某种语言编写程序代码:例如,C或C++或Fortran(但通常不是Java,因为Java通常以不同的方式工作,使用加载器而不是链接器)。编译器将这种程序代码(即人类可读的文本)转换成另一种人类可读的文本,称为汇编代码。汇编代码是计算机可以直接执行的机器语言的可读形式。汇编器用于将这种汇编代码转换成目标文件。为了完整起见,我要注意到一些编译器内部包含一个汇编器,直接生成目标文件。无论哪种方式,这就是事情变得有趣的地方。

在过去,当恐龙在数据中心游荡时,许多程序本身就是完整的。在那些日子里,通常没有编译器 - 人们直接用汇编代码编写 - 汇编器实际上生成了机器可以直接执行的可执行文件。

随着像Fortran和Cobol这样的语言开始出现,人们开始考虑子程序库,这意味着必须有某种方法在两个不同的时间运行汇编器,并将输出合并成一个可执行文件。这要求汇编器生成一种不同类型的输出,这种输出被称为目标文件(我不知道这个名字是从哪里来的)。还需要一个新程序将不同的目标文件组合成一个可执行文件。这个新程序被称为链接器(这个名字的来源应该是显而易见的)。

链接器今天仍然做同样的工作。在随后的几十年里,添加了一个新功能:共享库。

明天会有更多内容。
