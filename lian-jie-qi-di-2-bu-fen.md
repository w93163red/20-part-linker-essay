---
description: 2007年8月23日下午10:18 · 归档于编程
---

# 链接器第2部分

我回来了,我还在进行链接器技术介绍。

共享库的发明是为了优化同时运行多个进程的虚拟内存系统。人们注意到,几乎每个程序都有一组基本函数。在共享库之前,在同时运行多个进程的系统中,这意味着几乎每个进程都有完全相同代码的副本。这表明在虚拟内存系统上,可以安排代码使得每个使用它的进程可以共享单一副本。虚拟内存系统将被用来将单一副本映射到需要它的每个进程的地址空间。这将需要更少的物理内存来运行多个程序,从而产生更好的性能。

我相信共享库的第一个实现是在SVR3上,基于COFF。这个实现很简单,基本上为每个共享库分配了虚拟地址空间的固定部分。这不需要对链接器进行任何重大更改。然而,要求每个共享库保留适当的虚拟地址空间部分是不方便的。

SunOS4引入了一个更灵活的共享库版本,后来被SVR4采用。这种实现将链接器的一些操作推迟到运行时。当程序启动时,它会自动运行链接器的一个有限版本,该版本将程序本身与共享库链接。在程序启动时运行的链接器版本被称为动态链接器。当需要区分它们时,我将把创建程序的链接器版本称为程序链接器。这种类型的共享库对传统的程序链接器是一个重大变化:它现在必须构建链接信息,这些信息可以在运行时由动态链接器高效使用。

这就是介绍的结束。你现在应该理解链接器做什么的基础知识了。我现在将转向它是如何做的。

## 基本链接器数据类型

链接器操作少量基本数据类型:符号、重定位和内容。这些在输入目标文件中定义。以下是每种类型的概述。

符号基本上是一个名称和一个值。许多符号代表原始源代码中的静态对象 - 即在程序持续时间内存在于单一位置的对象。例如,在从C代码生成的目标文件中,每个函数和每个全局和静态变量都会有一个符号。这种符号的值只是内容的偏移量。这种类型的符号被称为定义符号。重要的是不要混淆表示变量my\_global\_var的符号的值与my\_global\_var本身的值。符号的值大致是变量的地址:你在C中从表达式\&my\_global\_var得到的值。

符号也用于指示对在不同目标文件中定义的名称的引用。这种引用被称为未定义符号。还有其他不太常用的符号类型,我稍后会描述。

在链接过程中,链接器将为每个定义的符号分配一个地址,并通过找到具有相同名称的定义符号来解析每个未定义符号。

重定位是对内容执行的计算。大多数重定位引用一个符号和内容中的偏移量。许多重定位还将提供一个额外的操作数,称为加数。一个简单且常用的重定位是"将内容中的这个位置设置为这个符号的值加上这个加数"。重定位进行的计算类型本质上取决于链接器为其生成代码的处理器的架构。例如,需要两条或更多指令来形成内存地址的RISC处理器将有单独的重定位,用于每个指令;例如,"将内容中的这个位置设置为这个符号值的低16位"。

在链接过程中,链接器将按指示执行所有重定位计算。目标文件中的重定位可能引用未定义的符号。如果链接器无法解析该符号,通常会发出错误(但并非总是如此:对于某些符号类型或某些重定位类型,错误可能不适当)。

内容是程序执行期间内存应该看起来的样子。内容有一个大小、一个字节数组和一个类型。它们包含编译器和汇编器生成的机器代码(称为文本)。它们包含初始化变量的值(数据)。它们包含静态未命名数据,如字符串常量和开关表(只读数据或rdata)。它们包含未初始化的变量,在这种情况下,字节数组通常被省略,并假定只包含零(bss)。编译器和汇编器努力生成完全正确的内容,但链接器真的不关心它们,除了作为原始数据。链接器从每个文件读取内容,将它们按类型排序连接在一起,应用重定位,并将结果写入可执行文件。

## 基本链接器操作

在这一点上,我们已经知道足够多的内容,可以理解每个链接器使用的基本步骤。

* 读取输入目标文件。确定内容的长度和类型。读取符号。
* 构建包含所有符号的符号表,将未定义符号链接到它们的定义。
* 决定所有内容应该在输出可执行文件中的位置,这意味着决定它们在程序运行时应该在内存中的位置。
* 读取内容数据和重定位。将重定位应用于内容。将结果写入输出文件。
* 可选地写出带有符号最终值的完整符号表。

明天会有更多内容。
